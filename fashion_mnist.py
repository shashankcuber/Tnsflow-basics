# -*- coding: utf-8 -*-
"""Fashion mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18bB1voODo59Ry-tdWwJm4dVJx7IC36Aq
"""

#import tensorflow and tensorflow datasets
import tensorflow as tf
import tensorflow_datasets as tfds
tf.logging.set_verbosity(tf.logging.ERROR)

#helper functions
import numpy as np
import math
import matplotlib.pyplot as plt

#improve progress bar display
import tqdm
import tqdm.auto
tqdm.tqdm=tqdm.auto.tqdm

#print(tf._version_)

#to use data_set.iter so eager shoudl be enabled
tf.enable_eager_execution()

#importing fashion mnist data set
dataset,metadata=tfds.load('fashion_mnist',as_supervised=True,with_info=True)
train=dataset['train']
test=dataset['test']

#now attaching class names to each label for future plotting purpose
#to all the possible outcomes from 0 to 9
class_names=['T-shirt/top','Trouser','Pullover','Dress','Coat'
       'Sandal','Shirt','Sneaker','Bag','Ankle boot']

#Just see the data division on the basis of testing and training
num_train=metadata.splits['train'].num_examples
num_test=metadata.splits['test'].num_examples
print(num_train)
print(num_test)

#preprocess the data
#the pixels value are from [0,255] we have to normalise the value to [0,1]

#normalizing function
def normalize(images,labels):
#tf.cast just like typecasting in cpp for changing images real value
  images=tf.cast(images,tf.float32)
  #normalising to 0 and 1
  images/=255
  return images,labels

#nomralizing the train and test
train=train.map(normalize)
test=test.map(normalize)

#explore the preprocessed data
#changing the color dimensions by changing value of dimensions 
for image,label in test.take(1):
  break
image=image.numpy().reshape((28,28)) 

#plot the image 
plt.figure()
plt.imshow(image,cmap=plt.cm.binary)
plt.colorbar()
plt.grid(False)
plt.show()

#display the first 25 images
plt.figure(figsize=(10,10))
i=0
for (image,label) in test.take(25):
  image=image.numpy().reshape((28,28))
  #dimension for 25 images i.e 5*5
  plt.subplot(5,5,i+1)
  plt.xticks([])
  plt.yticks([])
  plt.grid(False)
  plt.imshow(image,cmap=plt.cm.binary)
  #plt.xlabel(class_names[label])
  i+=1
plt.show()

#Building the model

#Adding layers
model=tf.keras.Sequential([
                          tf.keras.layers.Flatten(input_shape=(28,28,1)),
                          tf.keras.layers.Dense(128,activation=tf.nn.relu),
                          tf.keras.layers.Dense(10,activation=tf.nn.softmax)
                          ])

#Compiling the model

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
             metrics=['accuracy'])

#Training the model
Batch_size=32
#shuffle so as to randomize the order of learning of the examples
#.batch() to use batch of 32 images while training
#repeat() to tell how long will we iterate to train
train=train.repeat().shuffle(num_train).batch(Batch_size)
test=test.batch(Batch_size)

#5 iterations i.e 5*60k = 3 L examples are trained and in each epoch its steps per epoch
model.fit(train,epochs=5,steps_per_epoch=math.ceil(num_train/Batch_size))

#Evaluating the accuracy

test_loss,test_accuracy=model.evaluate(test,steps=math.ceil(num_test/32))
print('Accuracy :{}'.format(test_accuracy))

#Making predictions
for test_images,test_labels in test.take(1):
  test_images=test_images.numpy()
  test_labels=test_labels.numpy()
  prediction=model.predict(test_images)

#Here the model has predicted the label for each image in the testing set.
#Like predicted an ith image belongd to ankle/boot i.e label 9 and so on
prediction.shape

#prediction label of the first image
#All the nine values is being predicted for an image now max of these values 
#be the final label for this
prediction[0]

#now finding the maxm value from 1D array
#output is 6 for the image 0 
np.argmax(prediction[0])

#truing to find the label name for it we
#defined in the class_name
class_names[test_labels[0]]

#Graphing the 10 class predictions

def plot_image(i,predictions_array,true_labels,images):
  predictions_array,true_label,img=predictions_array[i],true_labels[i],images[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])
  
  plt.imshow(img[...,0],cmap=plt.cm.binary)
  
  predicted_label=np.argmax(predictions_array)
  if predicted_label==true_label:
    color='blue'
  else:
    color='red'
    
  plt.xlabel("{}{:2.0f}% ({})".format(class_names[predicted_label],
                              100*np.max(predictions_array),
                              class_names[true_label]),
                              color=color)
  
def plot_value_array(i,predictions_array,true_label):
    predictions_array,true_label=predictions_array[i],true_label[i]
    plt.grid(False)
    plt.xticks([])
    plt.yticks([])
    thisplot=plt.bar(range(10),predictions_array,color="#777777")
    plt.ylim([0,1])
    predicted_label=np.argmax(predictions_array)
    
    thisplot[predicted_label].set_color('red')
    thisplot[true_label].set_color('blue')

i=0
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i,prediction,test_labels,test_images)
plt.subplot(1,2,2)
plot_value_array(i,prediction,test_labels)

#now for the 13th image
i=12
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i,prediction,test_labels,test_images)
plt.subplot(1,2,2)
plot_value_array(i,prediction,test_labels)

#Now for first x images see whether their true_label matches with predicted_label
num_rows=5
num_cols=3
num_images=num_rows*num_cols
plt.figure(figsize=(2*2*num_cols,2*num_rows))
for i in range(num_images):
  plt.subplot(num_rows,2*num_cols,2*i+1)
  plot_image(i,prediction,test_labels,test_images)
  plt.subplot(num_rows,2*num_cols,2*i+2)
  plot_value_array(i,prediction,test_labels)

#take an image from the data set to test
img=test_images[0]
print(img.shape)

#adding image to a batch lone
img=np.array([img])
print(img.shape)

predic=model.predict(img)
print(predic)

plot_value_array(0,predic,test_labels)
_=plt.xticks(range(10),class_names,rotation=45)

np.argmax(predic[0])